-- Abstract: create automod vote tables

\set ON_ERROR_STOP 1

BEGIN;

-- tables

CREATE TABLE cdtoc
(
    id                  SERIAL,
    discid              CHAR(28) NOT NULL,
    freedbid            CHAR(8) NOT NULL,
    trackcount          INTEGER NOT NULL,
    leadoutoffset       INTEGER NOT NULL,
    trackoffset         INTEGER[] NOT NULL
);

CREATE TABLE album_cdtoc
(
    id                  SERIAL,
    album               INTEGER NOT NULL,
    cdtoc               INTEGER NOT NULL,
    modpending          INTEGER NOT NULL DEFAULT 0
);

-- data

-- This data is either generated by 20040730-1.pl, or can be downloaded from
-- the MB FTP site
\copy cdtoc from /tmp/20040730-cdtoc.dat
\copy album_cdtoc from /tmp/20040730-album_cdtoc.dat

-- primary key

ALTER TABLE cdtoc ADD CONSTRAINT cdtoc_pkey PRIMARY KEY (id);
ALTER TABLE album_cdtoc ADD CONSTRAINT album_cdtoc_pkey PRIMARY KEY (id);

-- constraints

alter table cdtoc add constraint cdtoc_discid check (
    discid ~ '[0-9a-zA-Z._-]{27}-'
);
alter table cdtoc add constraint cdtoc_freedbid check (
    freedbid ~ '[0-9a-f]{8}'
);
alter table cdtoc add constraint cdtoc_trackcount check (
    trackcount BETWEEN 1 and 99
);
alter table cdtoc add constraint cdtoc_trackoffsetcount check (
    array_upper(trackoffset, 1) = trackcount
);
-- TODO check that track offsets, leadoutoffset are increasing?

-- indexes

CREATE INDEX cdtoc_discid ON cdtoc (discid);
CREATE INDEX cdtoc_freedbid ON cdtoc (freedbid);
CREATE UNIQUE INDEX cdtoc_toc ON cdtoc (trackcount, leadoutoffset, trackoffset);
CREATE UNIQUE INDEX album_cdtoc_albumcdtoc ON album_cdtoc (album, cdtoc);

-- FKs

ALTER TABLE album_cdtoc
    ADD CONSTRAINT album_cdtoc_fk_album
    FOREIGN KEY (album)
    REFERENCES album(id);

ALTER TABLE album_cdtoc
    ADD CONSTRAINT album_cdtoc_fk_cdtoc
    FOREIGN KEY (cdtoc)
    REFERENCES cdtoc(id);

SELECT SETVAL('cdtoc_id_seq', c+1) FROM (SELECT MAX(id) AS c FROM cdtoc) t;
SELECT SETVAL('album_cdtoc_id_seq', c+1) FROM (SELECT MAX(id) AS c FROM album_cdtoc) t;

DROP TRIGGER "reptg_discid" ON "discid";
DROP TRIGGER "reptg_toc" ON "toc";

DROP TRIGGER a_del_discid ON discid;
DROP TRIGGER a_upd_discid ON discid;
DROP TRIGGER a_ins_discid ON discid;

ALTER TABLE discid DROP CONSTRAINT discid_fk_album;
ALTER TABLE toc DROP CONSTRAINT toc_fk_album;

ALTER TABLE discid RENAME TO old_discid;
ALTER TABLE toc RENAME TO old_toc;

--'-----------------------------------------------------------------
-- Populate the albummeta table, one-to-one join with album.
-- All columns are non-null integers, except firstreleasedate
-- which is CHAR(10) WITH NULL
--'-----------------------------------------------------------------

create or replace function fill_album_meta () returns integer as '
declare

   table_count integer;

begin

   table_count := (SELECT count(*) FROM pg_class WHERE relname = ''albummeta'');
   if table_count > 0 then
       raise notice ''Dropping existing albummeta table'';
       drop table albummeta;
   end if;

   raise notice ''Counting tracks'';
   create temporary table albummeta_tracks as select album.id, count(albumjoin.album) 
                from album left join albumjoin on album.id = albumjoin.album group by album.id;

   raise notice ''Counting discids'';
   create temporary table albummeta_discids as select album.id, count(album_cdtoc.album) 
                from album left join album_cdtoc on album.id = album_cdtoc.album group by album.id;

   raise notice ''Counting trmids'';
   create temporary table albummeta_trmids as select album.id, count(trmjoin.track) 
                from album, albumjoin left join trmjoin on albumjoin.track = trmjoin.track 
                where album.id = albumjoin.album group by album.id;

    raise notice ''Finding first release dates'';
    CREATE TEMPORARY TABLE albummeta_firstreleasedate AS
        SELECT  album AS id, MIN(releasedate)::CHAR(10) AS firstreleasedate
        FROM    release
        GROUP BY album;

   raise notice ''Creating albummeta table'';
   create table albummeta as
   select a.id,
            COALESCE(t.count, 0) AS tracks,
            COALESCE(d.count, 0) AS discids,
            COALESCE(m.count, 0) AS trmids,
            r.firstreleasedate,
            aws.asin,
            aws.coverarturl
    FROM    album a
            LEFT JOIN albummeta_tracks t ON t.id = a.id
            LEFT JOIN albummeta_discids d ON d.id = a.id
            LEFT JOIN albummeta_trmids m ON m.id = a.id
            LEFT JOIN albummeta_firstreleasedate r ON r.id = a.id
            LEFT JOIN album_amazon_asin aws on aws.album = a.id
            ;

    ALTER TABLE albummeta ALTER COLUMN id SET NOT NULL;
    ALTER TABLE albummeta ALTER COLUMN tracks SET NOT NULL;
    ALTER TABLE albummeta ALTER COLUMN discids SET NOT NULL;
    ALTER TABLE albummeta ALTER COLUMN trmids SET NOT NULL;
    -- firstreleasedate stays "WITH NULL"
    -- asin stays "WITH NULL"
    -- coverarturl stays "WITH NULL"

   create unique index albummeta_id on albummeta(id);

   drop table albummeta_tracks;
   drop table albummeta_discids;
   drop table albummeta_trmids;
   drop table albummeta_firstreleasedate;

   return 1;

end;
' language 'plpgsql';

--'-----------------------------------------------------------------
-- Changes to album_cdtoc could cause changes to albummeta.discids
--'-----------------------------------------------------------------

create or replace function a_ins_album_cdtoc () returns trigger as '
begin
    UPDATE  albummeta
    SET     discids = discids + 1
    WHERE   id = NEW.album;

    return NULL;
end;
' language 'plpgsql';
--'--
create or replace function a_upd_album_cdtoc () returns trigger as '
begin
    if NEW.album = OLD.album
    then
        return NULL;
    end if;

    UPDATE  albummeta
    SET     discids = discids - 1
    WHERE   id = OLD.album;

    UPDATE  albummeta
    SET     discids = discids + 1
    WHERE   id = NEW.album;

    return NULL;
end;
' language 'plpgsql';
--'--
create or replace function a_del_album_cdtoc () returns trigger as '
begin
    UPDATE  albummeta
    SET     discids = discids - 1
    WHERE   id = OLD.album;

    return NULL;
end;
' language 'plpgsql';

CREATE TRIGGER a_ins_album_cdtoc AFTER INSERT ON album_cdtoc
    FOR EACH ROW EXECUTE PROCEDURE a_ins_album_cdtoc();
CREATE TRIGGER a_upd_album_cdtoc AFTER UPDATE ON album_cdtoc
    FOR EACH ROW EXECUTE PROCEDURE a_upd_album_cdtoc();
CREATE TRIGGER a_del_album_cdtoc AFTER DELETE ON album_cdtoc
    FOR EACH ROW EXECUTE PROCEDURE a_del_album_cdtoc();

COMMIT;

\unset ON_ERROR_STOP

-- replication triggers, if we're a master

CREATE TRIGGER "reptg_cdtoc" 
AFTER INSERT OR DELETE OR UPDATE ON "cdtoc"
FOR EACH ROW EXECUTE PROCEDURE "recordchange" ();

CREATE TRIGGER "reptg_album_cdtoc" 
AFTER INSERT OR DELETE OR UPDATE ON "album_cdtoc"
FOR EACH ROW EXECUTE PROCEDURE "recordchange" ();

-- vi: set ts=4 sw=4 et :
